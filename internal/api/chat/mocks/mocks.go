// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/waryataw/chat-server/internal/api/chat.Service -o mocks.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements mm_chat.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, usernames []string) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, usernames []string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mServiceMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mServiceMockDelete

	funcSendMessage          func(ctx context.Context, from string, text string) (err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, from string, text string)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mServiceMockSendMessage
}

// NewServiceMock returns a mock for mm_chat.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ServiceMockCreateParams{}

	m.DeleteMock = mServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ServiceMockDeleteParams{}

	m.SendMessageMock = mServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockCreate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateExpectation
	expectations       []*ServiceMockCreateExpectation

	callArgs []*ServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateExpectation specifies expectation struct of the Service.Create
type ServiceMockCreateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateParams
	paramPtrs          *ServiceMockCreateParamPtrs
	expectationOrigins ServiceMockCreateExpectationOrigins
	results            *ServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateParams contains parameters of the Service.Create
type ServiceMockCreateParams struct {
	ctx       context.Context
	usernames []string
}

// ServiceMockCreateParamPtrs contains pointers to parameters of the Service.Create
type ServiceMockCreateParamPtrs struct {
	ctx       *context.Context
	usernames *[]string
}

// ServiceMockCreateResults contains results of the Service.Create
type ServiceMockCreateResults struct {
	i1  int64
	err error
}

// ServiceMockCreateOrigins contains origins of expectations of the Service.Create
type ServiceMockCreateExpectationOrigins struct {
	origin          string
	originCtx       string
	originUsernames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mServiceMockCreate) Optional() *mServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Service.Create
func (mmCreate *mServiceMockCreate) Expect(ctx context.Context, usernames []string) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ServiceMockCreateParams{ctx, usernames}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Service.Create
func (mmCreate *mServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUsernamesParam2 sets up expected param usernames for Service.Create
func (mmCreate *mServiceMockCreate) ExpectUsernamesParam2(usernames []string) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.usernames = &usernames
	mmCreate.defaultExpectation.expectationOrigins.originUsernames = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Service.Create
func (mmCreate *mServiceMockCreate) Inspect(f func(ctx context.Context, usernames []string)) *mServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Service.Create
func (mmCreate *mServiceMockCreate) Return(i1 int64, err error) *ServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ServiceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the Service.Create method
func (mmCreate *mServiceMockCreate) Set(f func(ctx context.Context, usernames []string) (i1 int64, err error)) *ServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Service.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Service.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the Service.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mServiceMockCreate) When(ctx context.Context, usernames []string) *ServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	expectation := &ServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ServiceMockCreateParams{ctx, usernames},
		expectationOrigins: ServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Service.Create return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateExpectation) Then(i1 int64, err error) *ServiceMock {
	e.results = &ServiceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Service.Create should be invoked
func (mmCreate *mServiceMockCreate) Times(n uint64) *mServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_chat.Service
func (mmCreate *ServiceMock) Create(ctx context.Context, usernames []string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, usernames)
	}

	mm_params := ServiceMockCreateParams{ctx, usernames}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateParams{ctx, usernames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.usernames != nil && !minimock.Equal(*mm_want_ptrs.usernames, mm_got.usernames) {
				mmCreate.t.Errorf("ServiceMock.Create got unexpected parameter usernames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUsernames, *mm_want_ptrs.usernames, mm_got.usernames, minimock.Diff(*mm_want_ptrs.usernames, mm_got.usernames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, usernames)
	}
	mmCreate.t.Fatalf("Unexpected call to ServiceMock.Create. %v %v", ctx, usernames)
	return
}

// CreateAfterCounter returns a count of finished ServiceMock.Create invocations
func (mmCreate *ServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ServiceMock.Create invocations
func (mmCreate *ServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mServiceMockCreate) Calls() []*ServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mServiceMockDelete struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteExpectation
	expectations       []*ServiceMockDeleteExpectation

	callArgs []*ServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteExpectation specifies expectation struct of the Service.Delete
type ServiceMockDeleteExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteParams
	paramPtrs          *ServiceMockDeleteParamPtrs
	expectationOrigins ServiceMockDeleteExpectationOrigins
	results            *ServiceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteParams contains parameters of the Service.Delete
type ServiceMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// ServiceMockDeleteParamPtrs contains pointers to parameters of the Service.Delete
type ServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ServiceMockDeleteResults contains results of the Service.Delete
type ServiceMockDeleteResults struct {
	err error
}

// ServiceMockDeleteOrigins contains origins of expectations of the Service.Delete
type ServiceMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mServiceMockDelete) Optional() *mServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Service.Delete
func (mmDelete *mServiceMockDelete) Expect(ctx context.Context, id int64) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ServiceMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Service.Delete
func (mmDelete *mServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for Service.Delete
func (mmDelete *mServiceMockDelete) ExpectIdParam2(id int64) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Service.Delete
func (mmDelete *mServiceMockDelete) Inspect(f func(ctx context.Context, id int64)) *mServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Service.Delete
func (mmDelete *mServiceMockDelete) Return(err error) *ServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ServiceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Service.Delete method
func (mmDelete *mServiceMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *ServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Service.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Service.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Service.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mServiceMockDelete) When(ctx context.Context, id int64) *ServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	expectation := &ServiceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &ServiceMockDeleteParams{ctx, id},
		expectationOrigins: ServiceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Service.Delete return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Service.Delete should be invoked
func (mmDelete *mServiceMockDelete) Times(n uint64) *mServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_chat.Service
func (mmDelete *ServiceMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := ServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to ServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished ServiceMock.Delete invocations
func (mmDelete *ServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ServiceMock.Delete invocations
func (mmDelete *ServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mServiceMockDelete) Calls() []*ServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mServiceMockSendMessage struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSendMessageExpectation
	expectations       []*ServiceMockSendMessageExpectation

	callArgs []*ServiceMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSendMessageExpectation specifies expectation struct of the Service.SendMessage
type ServiceMockSendMessageExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSendMessageParams
	paramPtrs          *ServiceMockSendMessageParamPtrs
	expectationOrigins ServiceMockSendMessageExpectationOrigins
	results            *ServiceMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSendMessageParams contains parameters of the Service.SendMessage
type ServiceMockSendMessageParams struct {
	ctx  context.Context
	from string
	text string
}

// ServiceMockSendMessageParamPtrs contains pointers to parameters of the Service.SendMessage
type ServiceMockSendMessageParamPtrs struct {
	ctx  *context.Context
	from *string
	text *string
}

// ServiceMockSendMessageResults contains results of the Service.SendMessage
type ServiceMockSendMessageResults struct {
	err error
}

// ServiceMockSendMessageOrigins contains origins of expectations of the Service.SendMessage
type ServiceMockSendMessageExpectationOrigins struct {
	origin     string
	originCtx  string
	originFrom string
	originText string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mServiceMockSendMessage) Optional() *mServiceMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for Service.SendMessage
func (mmSendMessage *mServiceMockSendMessage) Expect(ctx context.Context, from string, text string) *mServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ServiceMockSendMessageParams{ctx, from, text}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for Service.SendMessage
func (mmSendMessage *mServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectFromParam2 sets up expected param from for Service.SendMessage
func (mmSendMessage *mServiceMockSendMessage) ExpectFromParam2(from string) *mServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.from = &from
	mmSendMessage.defaultExpectation.expectationOrigins.originFrom = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectTextParam3 sets up expected param text for Service.SendMessage
func (mmSendMessage *mServiceMockSendMessage) ExpectTextParam3(text string) *mServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.text = &text
	mmSendMessage.defaultExpectation.expectationOrigins.originText = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the Service.SendMessage
func (mmSendMessage *mServiceMockSendMessage) Inspect(f func(ctx context.Context, from string, text string)) *mServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by Service.SendMessage
func (mmSendMessage *mServiceMockSendMessage) Return(err error) *ServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ServiceMockSendMessageResults{err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the Service.SendMessage method
func (mmSendMessage *mServiceMockSendMessage) Set(f func(ctx context.Context, from string, text string) (err error)) *ServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the Service.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the Service.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the Service.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mServiceMockSendMessage) When(ctx context.Context, from string, text string) *ServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ServiceMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ServiceMockSendMessageParams{ctx, from, text},
		expectationOrigins: ServiceMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up Service.SendMessage return parameters for the expectation previously defined by the When method
func (e *ServiceMockSendMessageExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times Service.SendMessage should be invoked
func (mmSendMessage *mServiceMockSendMessage) Times(n uint64) *mServiceMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ServiceMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mServiceMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_chat.Service
func (mmSendMessage *ServiceMock) SendMessage(ctx context.Context, from string, text string) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, from, text)
	}

	mm_params := ServiceMockSendMessageParams{ctx, from, text}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSendMessageParams{ctx, from, text}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ServiceMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.from != nil && !minimock.Equal(*mm_want_ptrs.from, mm_got.from) {
				mmSendMessage.t.Errorf("ServiceMock.SendMessage got unexpected parameter from, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originFrom, *mm_want_ptrs.from, mm_got.from, minimock.Diff(*mm_want_ptrs.from, mm_got.from))
			}

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmSendMessage.t.Errorf("ServiceMock.SendMessage got unexpected parameter text, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originText, *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ServiceMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, from, text)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ServiceMock.SendMessage. %v %v %v", ctx, from, text)
	return
}

// SendMessageAfterCounter returns a count of finished ServiceMock.SendMessage invocations
func (mmSendMessage *ServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ServiceMock.SendMessage invocations
func (mmSendMessage *ServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mServiceMockSendMessage) Calls() []*ServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockSendMessageDone()
}
